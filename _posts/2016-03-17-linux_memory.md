---
layout: slide
title: Linuxにおけるメモリ管理の基本
tag: [slide, Linux, Japanese]
---

### Linuxにおけるメモリ管理の基本

---
### 構成
- - -

* メモリとは？
* 仮想メモリ方式
* アドレス変換
* ページング
* ページ置換

---
### 構成
- - -

* <span style="color:red">メモリとは？</span>
* 仮想メモリ方式
* アドレス変換
* ページング
* ページ置換

---
### メモリとは？
- - -

* コンピュータにおいて  
  プログラムやデータを記憶する装置のこと
  - 主記憶装置、メインメモリとも
  - プログラムを実行するとプログラム(機械語)が  
    外部記憶装置(HDDなど)からメモリに読み込まれる
  - CPUはメモリを直接読み書きしてプログラムを実行
  - メモリ上のデータはアドレスによって管理される

---
### 構成
- - -

* メモリとは？
* <span style="color:red">仮想メモリ方式</span>
* アドレス変換
* ページング
* ページ置換

---
### 仮想メモリ方式(仮想記憶方式)とは
- - -

* 主記憶上のデータは物理アドレスとは別の  
  **仮想アドレス**によって管理される

* 仮想メモリ方式では  
  物理アドレス空間および仮想アドレス空間を  
  一定のサイズの**ページ**に分割して管理する
  - **ページング方式**

---
### 物理アドレスへの変換
- - -

* 実行しているプログラムがデータを更新する
  - **ページテーブル**を用いて  
    仮想アドレスを物理アドレスに変換
  - 物理アドレスに存在するデータを取得

* アドレス変換の仕組みは後のスライドで説明

---
### 仮想メモリ方式の利点(1)
- - -

* アドレス空間を主記憶容量以上に見せられる
  - 外部記憶装置(HDDなど)にスワップ領域を設け  
    仮想アドレスを割り当てる
    + 主記憶の一部として使用可能

---
### 仮想メモリ方式の利点(2)
- - -

* 効率の良いメモリ割当て

---
### メモリ割当ての管理手法
- - -

* ビットマップ方式
  - 割当単位ごとに  
    割当て済みor空きかを1bitで表す
* リスト方式
  - 空き領域を1つのリストとして管理
  - first fit, best fit, worst fitなど


---
### メモリ領域割当てアルゴリズム(1)
- - -

<img src="/assets/images/linux_memory/first_fit.png" width="70%">

* first fit
  - 要求サイズを満たす空き領域を  
    見つかった順に割り当てる
  - 長所: 単純
  - 短所: メモリ利用効率が悪い

---
### メモリ領域割当てアルゴリズム(2)
- - -

<img src="/assets/images/linux_memory/best_fit.png" width="70%">

* best fit
  - 要求サイズを満たす  
    最小の空き領域から割り当てる
  - 長所: 比較的メモリ効率が良い
  - 短所: 最適な空き領域を見つける  
    オーバーヘッドが大きい

---
### メモリ領域割当てアルゴリズム(3)
- - -

<img src="/assets/images/linux_memory/worst_fit.png" width="70%">

* worst fit
  - 最大の空き領域に割り当てる
  - 短所: メモリ利用効率が最も悪い

---
### 断片化
- - -

* 領域の割り当て、解放を繰り返すことで  
  **断片化**が起こる
  - メモリ領域の中に空き領域が多数存在する状態

* 1つの対策はメモリの詰め直し(**デフラグ**)

---
### ページ化による効率の良い割当て
- - -

<img src="/assets/images/linux_memory/memory_allocation_by_page.png" width="70%">

* 要求される領域をブロック(ページ)に分け  
  空いている領域のブロックに割り当てる
  - 断片化によるロスを抑えられる

* **内部断片化**が起こる
  - 最後のページ内に未使用部分ができる
  - ページサイズを小さくすることで
    ある程度防げる

---
### 仮想メモリ方式の利点(3)
- - -

* メモリ領域の保護
  - プロセスは独立した仮想アドレス空間を持つ
    + **多重アドレス空間**

* 複数プロセスが主記憶を安全に分割して使用可能

---
### 構成
- - -

* メモリとは？
* 仮想メモリ方式
* <span style="color:red">アドレス変換</span>
* ページング
* ページ置換

---
### アドレス変換
- - -

* プログラム実行時にメモリアクセスが起きると  
  仮想アドレスを物理アドレスに変換する
  - **MMU** (memory management unit)がおこなう

* 仮想アドレス=仮想ページ番号+ページ内オフセット  
  物理アドレス=物理ページ番号+ページ内オフセット
  - オフセットは仮想アドレスと物理アドレスで同じ

---
### アドレス変換の流れ(1)
- - -

* 例: 1ページが4KB、32bitシステムの場合
  - 仮想アドレス
    + 仮想ページ番号(20bit)
    + ページ内オフセット(12bit)
  - 物理アドレス
    + 物理ページ番号(20bit)
    + ページ内オフセット(12bit)

---
### アドレス変換の流れ(2)
- - -

* アドレス変換
  - ページテーブルを参照して  
    仮想ページ番号(20bit)に対応する  
    物理ページ番号(20bit)を取得
  - 物理ページ番号(20bit)と  
    ページ内オフセット(12bit)から  
    物理アドレス(32bit)を得る

---
### ページフォルト
- - -

* ページテーブルには存在ビットがある
  - 存在ビットが1 => 主記憶上にページがある
  - 存在ビットが0 => 主記憶上にページがない

* 存在ビットが0の場合、**ページフォルト**が発生する
  - ページフォルト発生時の説明は後のスライドで

---
### TLB
- - -

* ページテーブルは主記憶上に存在する
  - アドレス変換のたびにメモリアクセスが発生
  - 高速化のため  
    ページテーブル専用のキャッシュを参照
    + **TLB** (translation lookaside buffer)
    + 仮想アドレスをキー、  
      物理アドレスを値として格納

---
### TLBの動作
- - -

* アドレス変換(with TLB)
  - TLBを参照
    + 仮想アドレスがキーとして存在した場合  
      対応する物理アドレスを取得
    + 存在しなかった場合  
      主記憶上のページテーブルを参照

---
### 構成
- - -

* メモリとは？
* 仮想メモリ方式
* アドレス変換
* <span style="color:red">ページング</span>
* ページ置換

---
### ページイン
- - -

* ページフォルトが発生すると  
  **ページイン**がおこなわれる
  - プロセスの実行に割り込み、  
    補助記憶装置上のページを  
    主記憶装置の空きページに書き込む動作
  - ページテーブルの存在ビットを1に修正し  
    主記憶装置に読み込み後  
    アドレス変換をおこなう

---
### ページアウト
- - -

* 主記憶上の空きページが少なくなると  
  **ページアウト**がおこなわれる
  - 主記憶装置上のいずれかのページを  
    補助記憶装置上に追い出す動作
  - ページテーブルの存在ビットを0に修正し  
    補助記憶装置にページを退避

---
### スラッシング
- - -

* メモリが枯渇気味のとき  
  各プロセスでページングが頻発
  - **スラッシング**により性能が大幅に低下

* **OOM Killer**により  
  メモリ使用量の多いかつ優先度の低いプロセスが
  terminateされることも

---
### ページキャッシュ
- - -

* メモリが枯渇気味に見える場合がある
  - Linuxは一度アクセスしたデータを  
    可能な限りメモリに保持する
    + **ページキャッシュ**
  - キャッシュではなく  
    実際のメモリ使用量に着目

---
### 構成
- - -

* メモリとは？
* 仮想メモリ方式
* アドレス変換
* ページング
* <span style="color:red">ページ置換</span>

---
### ページ置換
- - -

* 物理ページ数には限りがある
  - どのページを主記憶上に保持し  
    どのページをスワップ領域に退避させるかの戦略
  - **ページ置換** or **メモリスケジューリング**

---
### ページ置換のポリシー
- - -

* グローバルポリシー
  - 複数アドレス空間から追い出すページを決定

* ローカルポリシー
  - 1つのアドレス空間から追い出すページを決定

---
### ページ置換アルゴリズム
- - -

* **NRU (Not Recently Used)**
  - 最近使われたページを残し  
    使われていないページをスワップアウトする

---
### 参照ビットと変更ビット
- - -

* ページごとに**参照ビット**と**変更ビット**が存在
  - ページが参照されるとビットが1にセット
    + 参照ビットは定期的にリセットされる
  - ページが変更されるとビットが1にセット

* 考えられる状態
  - 参照ビットが0、変更ビットが0
  - 参照ビットが0、変更ビットが1
  - 参照ビットが1、変更ビットが0
  - 参照ビットが1、変更ビットが1

* 上の状態ほどスワップアウトの対象になりやすい


---
### その他のページ置換アルゴリズム
- - -

* FIFO (First-In First-Out)
* セカンドチャンス
* LRU (Least Recently Used)

---
### まとめ
- - -

* 仮想アドレス方式により  
  実メモリ容量以上の領域を確保できる

* ページング方式により  
  効率的なメモリ割当てが可能に

---
### 参考文献・スライド
- - -

* 参考書籍
  - [野口健一郎(2002) IT Text オペレーティングシステム](https://www.ipsj.or.jp/tosho/9faeag0000005er1.html)
  - [坂井修一(2004) コンピュータアーキテクチャ](http://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-%E9%9B%BB%E5%AD%90%E6%83%85%E5%A0%B1%E9%80%9A%E4%BF%A1%E3%83%AC%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E5%9D%82%E4%BA%95-%E4%BF%AE%E4%B8%80/dp/4339018430)
* スライド
  * [メモリ管理、アドレス空間、ページテーブル](http://www.coins.tsukuba.ac.jp/~yas/coins/os2-2011/2012-01-24/)
  * [メモリ管理(2)](http://www.aist-nara.ac.jp/~yasumoto/lecture/syspro/os2008-5.pdf)
